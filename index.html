<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <style>
      /* Hide the tilt prompt panel */
      .tilt-prompt-panel, #tilt-prompt-panel {
        display: none !important;
      }
    </style>
<title>Particle Tilt Playground â€” Containers + Extra Turbulence</title>
<style>
  :root{
    --bg: #0b0e14;
    --panel: #121622ee;
    --panel2:#0f1320ee;
    --text:#e6edf3;
    --muted:#96a0aa;
    --accent:#6ae3ff;
    --accent2:#9b7bff;
    --good:#79ffa1;
    --warn:#ffcc66;
    --bad:#ff6677;
    --border:#202533;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;}
  canvas{position:fixed;inset:0;width:100vw;height:100vh;touch-action:none;display:block;}
  #hud{
    position:fixed;top:10px;left:10px;z-index:10;
    background:linear-gradient(180deg,#0f141d 0%, #0a0d14 100%);
    color:var(--text);border:1px solid var(--border);border-radius:10px;
    padding:8px 12px;font-size:12px;line-height:1.4;backdrop-filter: blur(6px);
    box-shadow:0 6px 20px rgba(0,0,0,0.25);
  }
  #hud .row{display:flex;gap:12px;flex-wrap:wrap}
  #hud .tag{padding:2px 8px;border-radius:999px;background:#0d111a;border:1px solid var(--border);color:var(--muted)}
  #hud .tag b{color:var(--text)}
  #hud .mode{color:var(--accent)}
  #hud .btn{
    margin-left:6px; padding:2px 8px;border-radius:6px;border:1px solid var(--border);
    background:#0e1220;color:var(--text);cursor:pointer;font-weight:600;
  }
  #hud .btn:hover{border-color:#2a2f40}
  #panel{
    position:fixed;right:14px;top:14px;bottom:14px;width:min(420px,92vw);
    display:flex;flex-direction:column;z-index:20;background:var(--panel);
    border:1px solid var(--border);border-radius:14px;overflow:hidden;
    backdrop-filter: blur(8px); box-shadow:0 10px 30px rgba(0,0,0,0.35);
  }
  #panelHeader{
    display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border);
    background:linear-gradient(180deg,#1a2030, #141a28);
  }
  #panelHeader .title{font-weight:800;letter-spacing:.3px}
  #panelHeader .actions{display:flex;gap:8px}
  #panelHeader button{
    padding:8px 10px;border-radius:10px;background:#0f1524;border:1px solid var(--border);color:var(--text);cursor:pointer;font-weight:700
  }
  #panelHeader button.primary{background:linear-gradient(180deg,#2a3553,#222a42);border-color:#2f3755}
  #tabs{display:flex;flex-wrap:wrap;gap:6px;padding:8px 10px;border-bottom:1px solid var(--border);background:var(--panel2)}
  #tabs button{
    padding:6px 10px;border-radius:999px;background:#0e1423;border:1px solid var(--border);color:var(--muted);cursor:pointer;font-weight:600;font-size:12px
  }
  #tabs button.active{color:var(--text);background:linear-gradient(180deg,#18203a,#121a30);border-color:#2a2f40}
  #content{flex:1;overflow:auto;padding:14px}
  .group{border:1px solid var(--border);border-radius:12px;padding:10px 10px;margin-bottom:12px;background:rgba(10,12,18,0.55)}
  .group h3{margin:0 0 8px 0;font-size:13px;letter-spacing:.2px;color:#a9b3c0}
  .ctrl{display:grid;grid-template-columns:1fr auto;gap:6px;align-items:center;margin:8px 0}
  .ctrl label{font-size:12px;color:#b4beca}
  .ctrl input[type="range"]{width:170px}
  .ctrl input[type="color"]{width:40px;height:28px;border:none;background:transparent}
  .ctrl select,.ctrl input[type="number"],.ctrl input[type="text"]{
    background:#0d1322;border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;min-width:140px
  }
  .ctrl .value{font-variant-numeric:tabular-nums;color:#cdd6e3;font-size:12px;}
  .rowline{display:flex;gap:6px;flex-wrap:wrap}
  .smallnote{font-size:11px;color:#8c97a6}
  .footerNote{font-size:11px;color:#7e8796;margin-top:6px;text-align:center}
  #tiltPrompt{
    position:fixed;inset:auto 0 0 0;z-index:15;background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.5));
    display:flex;justify-content:center;align-items:flex-end;padding:16px;pointer-events:none;
  }
  #tiltPrompt .bubble{
    pointer-events:auto; background:#12182a;border:1px solid var(--border);border-radius:14px; padding:12px;
    box-shadow:0 8px 24px rgba(0,0,0,.35); max-width:min(560px,92vw);
  }
  #tiltPrompt .bubble .row{display:flex;gap:8px;align-items:center}
  #tiltPrompt .bubble button{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:#0f1524;color:#fff;font-weight:700;cursor:pointer}
  #tiltPrompt .bubble button.primary{background:linear-gradient(180deg,#2a3553,#222a42);border-color:#2f3755}
  #togglePanel{
    position:fixed;left:10px;bottom:10px;z-index:30;background:#10162a;border:1px solid var(--border);
    color:var(--text);border-radius:999px;padding:8px 10px;cursor:pointer;font-weight:800;
  }
  #togglePanel small{color:#98a3b0}
  #panel.hidden{display:none}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:#0e1423;color:#8ea0b7;font-size:12px;margin-right:6px}
  .flex{display:flex;gap:8px;align-items:center}
  a, a:visited{text-decoration:none;color:var(--accent)}
      /* Force hide the tilt prompt panel */
      #tiltPrompt {
        display: none !important;
      }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div class="row">
    <span class="tag">FPS: <b id="fps">0</b></span>
    <span class="tag">Particles: <b id="pcount">0</b></span>
    <span class="tag">Collisions: <b id="collMode">elastic</b></span>
    <span class="tag">Turbulence: <b id="turbMode">none</b></span>
    <span class="tag">Tilt: <b id="tiltState">off</b></span>
    <span class="tag">Mouse Gravity: <b id="mouseG">on</b></span>
  </div>
  <div class="row" style="margin-top:6px">
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="stepBtn" title="Step one frame">Step</button>
    <button class="btn" id="resetBtn" title="Reset particles">Reset</button>
  </div>
</div>

<button id="togglePanel">â˜° Controls <small>(C)</small></button>

<div id="panel">
  <div id="panelHeader">
    <div class="title">Particle Tilt Playground</div>
    <div class="actions">
      <button id="enableTiltTop" class="primary">Enable Tilt</button>
      <button id="randomize">Randomize</button>
      <button id="presetMenu">Presets</button>
    </div>
  </div>
  <div id="tabs"></div>
  <div id="content"></div>
  <div class="footerNote">Tip: On desktop, click anywhere to set gravity direction. On mobile, tap Enable Tilt.</div>
</div>

<div id="tiltPrompt" hidden>
  <div class="bubble">
    <div class="row">
      <div class="flex" style="flex:1;gap:10px">
        <span class="chip">ðŸ“± Device Tilt</span>
        <div>To roll marbles with your phone, grant motion permission.</div>
      </div>
      <button id="enableTilt" class="primary">Enable Tilt</button>
      <button id="dismissTilt">Dismiss</button>
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';

  // Utilities
  const clamp = (x,a,b)=>x<a?a:(x>b?b:x);
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a=0,b=1)=>a + Math.random()*(b-a);
  const randInt=(a,b)=>Math.floor(rand(a,b+1));
  const TAU = Math.PI*2;
  const DEG = Math.PI/180;

  // Settings
  const Settings = {
    particles: {
      count: 1200,
      radiusMin: 2,
      radiusMax: 4,
      uniformSize: false, // NEW: if true, all particles use radiusMax
      shape: 'circle', // circle, square, triangle
      colorMode: 'velocity', // solid, velocity, heat
      solidColor: '#66ccff',
      palette: 'plasma', // plasma, cool, fire, aurora
      blend: 'lighter', // source-over, lighter, screen, multiply
      velocityColorScale: 350, // px/s
      opacity: 1.0,
      massMode: 'byArea', // constant, byArea, inverse, random
      mass: 1,
      randomMassMin: 0.4,
      randomMassMax: 2.0,
    },
    physics: {
      gravity: 40, // px/s^2
      tiltSensitivity: 1.0, // multiplies tilt vector magnitude
      airDrag: 0.06, // per second
      windX: 0,
      windY: 0,
      boundaries: 'screen-bounce', // screen-bounce, screen-wrap, none, container-circle, container-square
      restitution: 0.85, // bounciness walls+elastic
      wallFriction: 0.02, // tangential damp on wall/container hit
      particleFriction: 0.02, // tangential damp on particle collision
      container: { // for container-circle/square
        cx: 0.5, cy: 0.5,   // normalized center [0..1]
        radiusN: 0.45,      // normalized to half of min(viewport) for circle
        sizeN: 0.45         // half-size normalized (same basis) for square
      }
    },
    collisions: {
      mode: 'elastic', // elastic, soft, inelastic, none
      softness: 0.6, // for soft penalty
      inelasticity: 0.3, // 0..1 -> 0 bouncy 1 very sticky
      enable: true,
      adapt: true
    },
    forces: {
      turbulenceMode: 'none', // none, flow, curl, vortex, wind, jets, swirlgrid, wells
      amplitude: 140, // px/s^2 (general strength)
      scale: 0.0025,  // spatial scale for noise-based modes
      timeScale: 0.3, // field animation speed

      // Curl options
      curlStrength: 1.0,

      // Vortex (single center) options
      vortexX: 0.5,
      vortexY: 0.5,
      vortexStrength: 480,
      vortexFalloff: 1.2,
      vortexCW: true,

      // Wind options
      windVar: 0.0,
      windGust: 0.0,

      // Jets mode
      jetsAngle: 0,       // degrees
      jetsSpacing: 140,   // px between bands

      // Swirl Grid mode
      swirlSpacing: 160,  // px between vortex centers
      swirlFalloff: 1.2,  // falloff exponent
      swirlAlt: true,     // alternate CW/CCW per cell

      // Wells (multi-attractor) mode
      wellsCount: 4,
      wellsStrength: 800,
      wellsFalloff: 1.3,
      wellsSpin: 0.4,     // tangential swirl component 0..1+
      wellsMove: true,
      wellsRepel: false,
      wellsSeed: 12345
    },
    pointer: {
      enabled: false,
      tool: 'attract', // none, attract, repel, push, spin
      strength: 1100,
      radius: 140
    },
    visuals: {
      trail: 0.18, // fade per frame (0 clears fully, 1 = no clearing)
      background: '#0b0e14',
      showHUD: true,
      wireframe: false,
      showContainer: true // NEW: draw container outline for container modes
    },
    performance: {
      simSpeed: 1.0,
      substeps: 3,
      adaptive: false,
      lowFpsThreshold: 45,
      maxParticles: 8000,
      collisionCap: 12 // max neighbor pairs per particle (soft limit)
    },
    controls: {
      mouseSetsGravity: true
    }
  };

  // Presets
  const PRESETS = {
    Marbles: () => ({
      particles: { count: 800, shape: 'circle', radiusMin: 3, radiusMax: 6, uniformSize:false, colorMode:'solid', solidColor:'#88d0ff', blend:'source-over', massMode:'byArea', opacity:1 },
      physics: { gravity: 400, tiltSensitivity:1.2, airDrag:0.02, boundaries:'screen-bounce', restitution:0.85, wallFriction:0.1, windX:0, windY:0, particleFriction:0.03 },
      collisions: { mode:'elastic', softness:0.5, inelasticity:0.2, enable:true },
      forces: { turbulenceMode:'none', amplitude:0 },
      visuals: { trail:0.0, background:'#0b0e14', showContainer:true }
    }),
    CircleBowl: () => ({
      particles: { count: 900, radiusMin:3, radiusMax:5, uniformSize:false, shape:'circle', colorMode:'velocity', palette:'cool', blend:'lighter', massMode:'byArea', opacity:0.95 },
      physics: { gravity: 300, tiltSensitivity:1.0, airDrag:0.06, boundaries:'container-circle', container:{cx:0.5,cy:0.5,radiusN:0.44,sizeN:0.45}, restitution:0.85, wallFriction:0.08 },
      collisions: { mode:'soft', softness:0.75, enable:true },
      forces: { turbulenceMode:'flow', amplitude:100, scale:0.002, timeScale:0.3 },
      visuals: { trail:0.06, background:'#0b0e14', showContainer:true }
    }),
    SwirlGrid: () => ({
      particles: { count: 1500, radiusMin:2, radiusMax:3.5, uniformSize:false, shape:'circle', colorMode:'velocity', palette:'aurora', blend:'lighter', massMode:'constant', mass:0.7, opacity:0.95 },
      physics: { gravity: 0, tiltSensitivity:0.7, airDrag:0.06, boundaries:'screen-wrap', restitution:0.5, wallFriction:0.05 },
      collisions: { mode:'none', enable:true },
      forces: { turbulenceMode:'swirlgrid', amplitude:160, swirlSpacing:160, swirlFalloff:1.2, vortexCW:true, swirlAlt:true },
      visuals: { trail:0.22, background:'#07101a' }
    }),
    WellsDance: () => ({
      particles: { count: 1200, radiusMin:2, radiusMax:4, uniformSize:false, shape:'circle', colorMode:'velocity', palette:'plasma', blend:'lighter', massMode:'random', randomMassMin:.5, randomMassMax:1.4, opacity:0.95, velocityColorScale:420 },
      physics: { gravity: 0, tiltSensitivity: 0.5, airDrag:0.05, boundaries:'screen-wrap', restitution:0.6, wallFriction:0.02 },
      collisions: { mode:'none', enable:true },
      forces: { turbulenceMode:'wells', amplitude:0, wellsCount:5, wellsStrength:900, wellsFalloff:1.2, wellsSpin:0.5, wellsMove:true, wellsRepel:false, wellsSeed:2025 },
      visuals: { trail:0.18, background:'#05070d' }
    }),
    Jelly: () => ({
      particles: { count: 1000, radiusMin:5, radiusMax:5, uniformSize:true, shape:'circle', colorMode:'solid', solidColor:'#ffd580', blend:'source-over', massMode:'byArea', opacity:1.0 },
      physics: { gravity:90, tiltSensitivity:0.9, airDrag:0.08, boundaries:'container-square', container:{cx:0.5,cy:0.5,radiusN:0.45,sizeN:0.43}, restitution:0.2, wallFriction:0.15, windX:0, windY:0 },
      collisions: { mode:'soft', softness:0.85, enable:true },
      forces: { turbulenceMode:'none' },
      visuals: { trail:0.03, background:'#0b0e14', showContainer:true }
    })
  };

  // State
  let canvas = document.getElementById('c'), ctx = canvas.getContext('2d', {alpha:false});
  let W=0,H=0,DPR=1;
  let particles=[];
  let heatDecay = 0.97;
  let running = true, stepOnce=false;
  let gDir = {x:0,y:1}; // gravity direction, updated by tilt or mouse
  let tiltEnabled = false;
  let lastT=performance.now();
  let fpsSmooth = 60;
  let substeps = Settings.performance.substeps;
  let grid = new Map();
  let gridCell = 16; // updated later based on radius
  let frameCount = 0;
  let recentFps = [];

  // Pointer
  const pointer = {
    x:0,y:0, dx:0,dy:0, down:false, id:null, lastX:0,lastY:0, active:false
  };

  // HUD elements
  const hud = {
    fps: document.getElementById('fps'),
    pcount: document.getElementById('pcount'),
    collMode: document.getElementById('collMode'),
    turbMode: document.getElementById('turbMode'),
    tiltState: document.getElementById('tiltState'),
    mouseG: document.getElementById('mouseG'),
    pauseBtn: document.getElementById('pauseBtn'),
    stepBtn: document.getElementById('stepBtn'),
    resetBtn: document.getElementById('resetBtn'),
  };

  // Device tilt prompt
  const tiltPrompt = document.getElementById('tiltPrompt');
  const tiltBtn = document.getElementById('enableTilt');
  const tiltBtnTop = document.getElementById('enableTiltTop');
  const dismissTilt = document.getElementById('dismissTilt');

  // Panel/UI
  const panel = document.getElementById('panel');
  const tabsEl = document.getElementById('tabs');
  const contentEl = document.getElementById('content');
  const togglePanel = document.getElementById('togglePanel');
  const randomizeBtn = document.getElementById('randomize');
  const presetMenuBtn = document.getElementById('presetMenu');

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = Math.floor(w*DPR);
    canvas.height = Math.floor(h*DPR);
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    W = canvas.width; H = canvas.height;
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Palettes
  function paletteColor(t, name){
    t = clamp(t,0,1);
    switch(name){
      case 'plasma': {
        const r = Math.round(255 * clamp(Math.sin((t)*Math.PI)*0.8 + t*0.2 + 0.1,0,1));
        const g = Math.round(255 * clamp(Math.pow(t,0.5)*0.9,0,1));
        const b = Math.round(255 * clamp(1 - Math.pow(t,0.7),0,1));
        return `rgb(${r},${g},${b})`;
      }
      case 'cool': {
        const r = Math.round(255 * (1-t));
        const g = Math.round(255 * (0.5+0.5*t));
        const b = Math.round(255 * (t));
        return `rgb(${r},${g},${b})`;
      }
      case 'fire': {
        const r = Math.round(255 * clamp(1.2*t,0,1));
        const g = Math.round(255 * clamp(1.2*t-0.2,0,1));
        const b = Math.round(255 * clamp(0.8*t-0.5,0,1));
        return `rgb(${r},${g},${b})`;
      }
      case 'aurora':
      default: {
        const r = Math.round(255 * clamp(0.6*(1-t) + 0.1,0,1));
        const g = Math.round(255 * clamp(0.2 + t*0.8,0,1));
        const b = Math.round(255 * clamp(0.9 - t*0.6,0,1));
        return `rgb(${r},${g},${b})`;
      }
    }
  }

  // Noise helpers
  function hash(n){ n = (n<<13)^n; return 1.0 - ((n*(n*n*15731 + 789221) + 1376312589) & 0x7fffffff)/1073741824.0; }
  function noise2D(x,y){
    const xi = Math.floor(x), yi = Math.floor(y);
    let xf = x - xi, yf = y - yi;
    const s = (t)=>t*t*(3-2*t);
    const h = (ix,iy)=>hash(ix*374761393 + iy*668265263);
    const v00 = h(xi,yi), v10 = h(xi+1,yi), v01 = h(xi,yi+1), v11 = h(xi+1,yi+1);
    const u = s(xf), v = s(yf);
    return lerp(lerp(v00,v10,u), lerp(v01,v11,u), v)*0.5+0.5;
  }
  function curlNoise(x,y,t,scale=0.003, amp=1.0){
    const eps = 1.5;
    const n1 = noise2D(x*scale, y*scale + t);
    const nx1 = noise2D((x+eps)*scale, y*scale + t);
    const nx2 = noise2D((x-eps)*scale, y*scale + t);
    const ny1 = noise2D(x*scale, (y+eps)*scale + t);
    const ny2 = noise2D(x*scale, (y-eps)*scale + t);
    const dx = (nx1 - nx2)/(2*eps);
    const dy = (ny1 - ny2)/(2*eps);
    return {x: amp * (dy), y: amp * (-dx)};
  }
  function flowNoiseVec(x,y,t,scale=0.002, amp=1.0){
    const theta = noise2D(x*scale + t*0.31, y*scale - t*0.17) * TAU*2;
    return {x: Math.cos(theta)*amp, y: Math.sin(theta)*amp};
  }

  // PRNG for wells
  function LCG(seed){
    let s = (seed>>>0) || 1;
    return ()=>{ s = (1664525*s + 1013904223)>>>0; return s/4294967296; };
  }

  // Mass calc
  function massForRadius(r){
    switch(Settings.particles.massMode){
      case 'constant': return Settings.particles.mass;
      case 'byArea': return Math.PI*r*r*0.02;
      case 'inverse': return 1/(Math.PI*r*r*0.02 + 0.1);
      case 'random': return rand(Settings.particles.randomMassMin, Settings.particles.randomMassMax);
    }
    return 1;
  }

  // Particle factory
  function spawnPosFor(pRadius){
    const bMode = mapBoundaries(Settings.physics.boundaries);
    const BW = canvas.width/DPR, BH = canvas.height/DPR;
    if(bMode==='container-circle' || bMode==='container-square'){
      const cx = Settings.physics.container.cx * BW;
      const cy = Settings.physics.container.cy * BH;
      const minDim = Math.min(BW,BH);
      if(bMode==='container-circle'){
        const R = Settings.physics.container.radiusN * (minDim/2);
        const allowed = Math.max(4, R - pRadius);
        const a = rand(0, TAU);
        const rr = Math.sqrt(Math.random()) * Math.max(2, allowed);
        return { x: cx + Math.cos(a)*rr, y: cy + Math.sin(a)*rr };
      }else{
        const half = Settings.physics.container.sizeN * (minDim/2);
        const x = rand(cx - half + pRadius, cx + half - pRadius);
        const y = rand(cy - half + pRadius, cy + half - pRadius);
        return { x: clamp(x, pRadius, BW-pRadius), y: clamp(y, pRadius, BH-pRadius) };
      }
    }else{
      return {
        x: rand(pRadius, canvas.width/DPR - pRadius),
        y: rand(pRadius, canvas.height/DPR - pRadius)
      };
    }
  }
  function makeParticle(){
    const uniform = Settings.particles.uniformSize;
    const r = uniform ? Settings.particles.radiusMax : rand(Settings.particles.radiusMin, Settings.particles.radiusMax);
    const m = massForRadius(r);
    const pos = spawnPosFor(r);
    return {
      x: pos.x, y: pos.y, vx: rand(-40,40), vy: rand(-40,40),
      r, m,
      heat: 0,
      color: Settings.particles.solidColor
    };
  }

  function rebuildParticles(keepPositions=false){
    const target = clamp(Settings.particles.count, 0, Settings.performance.maxParticles);
    const prev = particles.slice(0);
    particles.length = 0;
    for(let i=0;i<target;i++){
      let p = makeParticle();
      if(keepPositions && prev[i]){
        p.x = clamp(prev[i].x, p.r, canvas.width/DPR - p.r);
        p.y = clamp(prev[i].y, p.r, canvas.height/DPR - p.r);
        p.vx = prev[i].vx; p.vy = prev[i].vy;
        p.heat = prev[i].heat * 0.8;
      }
      particles.push(p);
    }
    gridCell = Math.max(8, (Settings.particles.radiusMax*2)|0);
    updateHUD();
  }

  function applyUniformRadius(){
    if(!Settings.particles.uniformSize) return;
    const r = Settings.particles.radiusMax;
    for(const p of particles){
      p.r = r;
      p.m = massForRadius(r);
      p.x = clamp(p.x, r, canvas.width/DPR - r);
      p.y = clamp(p.y, r, canvas.height/DPR - r);
    }
    gridCell = Math.max(8, (Settings.particles.radiusMax*2)|0);
  }

  // Gravity from tilt or mouse
  let mouseGravity = {x:0, y:1};
  function setMouseGravityFromPoint(px,py){
    const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
    let dx = (px - cx), dy = (py - cy);
    const len = Math.hypot(dx,dy) || 1;
    mouseGravity.x = dx/len; mouseGravity.y = dy/len;
  }

  // Device orientation
  let haveDeviceOrientation = 'DeviceOrientationEvent' in window || 'DeviceMotionEvent' in window;
  function enableTiltRequest(){
    function onGranted(){
      tiltEnabled = true;
      updateHUD();
      tiltPrompt.hidden = true;
    }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      DeviceMotionEvent.requestPermission().then(res=>{
        if(res==='granted'){
          onGranted();
        }else{
          alert('Motion permission denied.');
        }
      }).catch(()=>alert('Motion permission request failed.'));
    }else{
      tiltEnabled = true;
      updateHUD();
      tiltPrompt.hidden = true;
    }
  }
  function onDeviceOrientation(e){
    if(!tiltEnabled) return;
    const beta = (e.beta||0)*DEG;
    const gamma = (e.gamma||0)*DEG;
    let gx = Math.sin(gamma);
    let gy = Math.sin(beta);
    const orient = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
    const a = (orient||0)*DEG;
    const rx = gx*Math.cos(-a) - gy*Math.sin(-a);
    const ry = gx*Math.sin(-a) + gy*Math.cos(-a);
    const len = Math.hypot(rx,ry) || 1;
    gDir.x = rx/len; gDir.y = ry/len;
  }
  window.addEventListener('deviceorientation', onDeviceOrientation, true);

  // Pointer events
  const pointerEl = canvas;
  function setPointer(e, type){
    const rect = canvas.getBoundingClientRect();
    let x,y,id=null;
    if(e.touches && e.touches[0]){
      const t = e.touches[0];
      id = t.identifier;
      x = t.clientX - rect.left;
      y = t.clientY - rect.top;
    }else{
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    pointer.dx = x - pointer.lastX;
    pointer.dy = y - pointer.lastY;
    pointer.lastX = pointer.x = x;
    pointer.lastY = pointer.y = y;
    if(type==='down'){ pointer.down = true; pointer.active = true; pointer.id = id; if(Settings.controls.mouseSetsGravity){ setMouseGravityFromPoint(x,y); } }
    else if(type==='up'){ pointer.down=false; pointer.id=null; pointer.dx=0; pointer.dy=0; }
  }
  pointerEl.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); setPointer(e,'down'); });
  pointerEl.addEventListener('pointermove', e=>{ setPointer(e,'move'); });
  pointerEl.addEventListener('pointerup', e=>{ setPointer(e,'up'); });
  pointerEl.addEventListener('pointercancel', e=>{ setPointer(e,'up'); });

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.key===' '){ running=!running; hud.pauseBtn.textContent = running?'Pause':'Resume'; e.preventDefault(); }
    if(e.key==='c' || e.key==='C'){ panel.classList.toggle('hidden'); }
    if(e.key==='g' || e.key==='G'){ Settings.controls.mouseSetsGravity = !Settings.controls.mouseSetsGravity; updateHUD(); }
    if(e.key==='r' || e.key==='R'){ rebuildParticles(false); }
    if(e.key==='f' || e.key==='F'){ Settings.visuals.showHUD = !Settings.visuals.showHUD; document.getElementById('hud').style.display = Settings.visuals.showHUD?'block':'none';}
  });

  // HUD buttons
  hud.pauseBtn.addEventListener('click', ()=>{ running=!running; hud.pauseBtn.textContent = running?'Pause':'Resume'; });
  hud.stepBtn.addEventListener('click', ()=>{ stepOnce = true; running=false; hud.pauseBtn.textContent = 'Resume'; });
  hud.resetBtn.addEventListener('click', ()=>{ rebuildParticles(false); });

  // Tilt buttons
  [tiltBtn, tiltBtnTop].forEach(btn=>btn.addEventListener('click', enableTiltRequest));
  dismissTilt.addEventListener('click', ()=>{ tiltPrompt.hidden = true; });

  // Panel toggle
  togglePanel.addEventListener('click', ()=> panel.classList.toggle('hidden'));

  // UI builder
  const TABS = [
    {id:'particles', name:'Particles'},
    {id:'physics', name:'Physics'},
    {id:'forces', name:'Forces'},
    {id:'collisions', name:'Collisions'},
    {id:'visuals', name:'Visuals'},
    {id:'interact', name:'Interaction'},
    {id:'performance', name:'Performance'},
    {id:'about', name:'About'}
  ];

  function pathGet(obj, path){ return path.split('.').reduce((o,k)=>o&&o[k], obj); }
  function pathSet(obj, path, val){
    const ks = path.split('.');
    const last = ks.pop();
    const parent = ks.reduce((o,k)=>o[k], obj);
    parent[last] = val;
  }

  function makeTabs(){
    tabsEl.innerHTML = '';
    TABS.forEach((t,i)=>{
      const b = document.createElement('button'); b.textContent=t.name; if(i===0) b.classList.add('active');
      b.addEventListener('click', ()=>{
        [...tabsEl.children].forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        showTab(t.id);
      });
      tabsEl.appendChild(b);
    });
    showTab('particles');
  }

  function ctrlRange(parent, path, label, min, max, step, fmtFn=(v)=>v, onChange=null){
    const wrap = document.createElement('div'); wrap.className='ctrl';
    const lab = document.createElement('label'); lab.textContent = label;
    const right = document.createElement('div'); right.className='rowline';
    const input = document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value=pathGet(Settings,path);
    const val = document.createElement('span'); val.className='value'; val.textContent = fmtFn(+input.value);
    input.addEventListener('input', ()=>{
      pathSet(Settings, path, parseFloat(input.value));
      val.textContent = fmtFn(parseFloat(input.value));
      if(onChange) onChange(parseFloat(input.value));
    });
    right.appendChild(input); right.appendChild(val);
    wrap.appendChild(lab); wrap.appendChild(right);
    parent.appendChild(wrap);
    return input;
  }
  function ctrlNumber(parent, path, label, step=1, onChange=null){
    const wrap = document.createElement('div'); wrap.className='ctrl';
    const lab = document.createElement('label'); lab.textContent=label;
    const input = document.createElement('input'); input.type='number'; input.value=pathGet(Settings,path); input.step=step;
    input.addEventListener('change', ()=>{ pathSet(Settings,path, parseFloat(input.value)); if(onChange) onChange(parseFloat(input.value)); });
    wrap.appendChild(lab); wrap.appendChild(input); parent.appendChild(wrap);
    return input;
  }
  function ctrlSelect(parent, path, label, options, onChange=null){
    const wrap = document.createElement('div'); wrap.className='ctrl';
    const lab = document.createElement('label'); lab.textContent = label;
    const sel = document.createElement('select');
    options.forEach(o=>{
      const opt = document.createElement('option'); opt.value=o.value; opt.textContent=o.name; sel.appendChild(opt);
    });
    sel.value = pathGet(Settings,path);
    sel.addEventListener('change', ()=>{ pathSet(Settings,path, sel.value); if(onChange) onChange(sel.value); });
    wrap.appendChild(lab); wrap.appendChild(sel); parent.appendChild(wrap);
    return sel;
  }
  function ctrlColor(parent, path, label, onChange=null){
    const wrap = document.createElement('div'); wrap.className='ctrl';
    const lab = document.createElement('label'); lab.textContent=label;
    const input = document.createElement('input'); input.type='color'; input.value=pathGet(Settings,path);
    input.addEventListener('input', ()=>{ pathSet(Settings,path,input.value); if(onChange) onChange(input.value); });
    wrap.appendChild(lab); wrap.appendChild(input); parent.appendChild(wrap);
    return input;
  }
  function ctrlCheck(parent, path, label, onChange=null){
    const wrap = document.createElement('div'); wrap.className='ctrl';
    const lab = document.createElement('label'); lab.textContent=label;
    const input = document.createElement('input'); input.type='checkbox'; input.checked=pathGet(Settings,path);
    input.addEventListener('change', ()=>{ pathSet(Settings,path,input.checked); if(onChange) onChange(input.checked); });
    wrap.appendChild(lab); wrap.appendChild(input); parent.appendChild(wrap);
    return input;
  }
  function group(title){
    const g = document.createElement('div'); g.className='group'; const h = document.createElement('h3'); h.textContent=title; g.appendChild(h); return g;
  }

  function showTab(id){
    contentEl.innerHTML = '';
    if(id==='particles'){
      const g1 = group('Particle Basics');

      // Uniform size toggle
      ctrlCheck(g1, 'particles.uniformSize', 'Uniform size', (v)=>{
        if(v){ Settings.particles.radiusMin = Settings.particles.radiusMax; applyUniformRadius(); }
        rebuildParticles(true); showTab('particles');
      });

      if(Settings.particles.uniformSize){
        ctrlRange(g1, 'particles.radiusMax', 'Size', 0.5, 20, 0.5, v=>v.toFixed(1), (v)=>{
          Settings.particles.radiusMin = v; applyUniformRadius();
        });
      }else{
        ctrlRange(g1, 'particles.count', 'Count', 0, Settings.performance.maxParticles, 1, v=>v, v=>rebuildParticles(true));
        ctrlRange(g1, 'particles.radiusMin', 'Size min', 0.5, 12, 0.5, v=>v.toFixed(1), v=>{ if(Settings.particles.radiusMin>Settings.particles.radiusMax){Settings.particles.radiusMax=Settings.particles.radiusMin; } rebuildParticles(true); });
        ctrlRange(g1, 'particles.radiusMax', 'Size max', 0.5, 20, 0.5, v=>v.toFixed(1), v=>{ if(Settings.particles.radiusMax<Settings.particles.radiusMin){Settings.particles.radiusMin=Settings.particles.radiusMax;} rebuildParticles(true); });
      }
      ctrlSelect(g1, 'particles.shape', 'Shape', [
        {value:'circle',name:'Circle'},
        {value:'square',name:'Square'},
        {value:'triangle',name:'Triangle'}
      ]);

      const g2 = group('Mass');
      ctrlSelect(g2, 'particles.massMode', 'Mass mode', [
        {value:'constant',name:'Constant'},
        {value:'byArea',name:'By area'},
        {value:'inverse',name:'Inverse of area'},
        {value:'random',name:'Random range'}
      ], ()=>{ applyUniformRadius(); rebuildParticles(true); });
      ctrlRange(g2, 'particles.mass', 'Constant mass', 0.1, 5, 0.1, v=>v.toFixed(2), ()=>{ applyUniformRadius(); rebuildParticles(true); });
      ctrlRange(g2, 'particles.randomMassMin', 'Random mass min', 0.1, 3, 0.1, v=>v.toFixed(2), ()=>rebuildParticles(true));
      ctrlRange(g2, 'particles.randomMassMax', 'Random mass max', 0.2, 4, 0.1, v=>v.toFixed(2), ()=>rebuildParticles(true));

      const g3 = group('Color & Blend');
      ctrlSelect(g3, 'particles.colorMode', 'Color mode', [
        {value:'solid',name:'Solid'},
        {value:'velocity',name:'Velocity'},
        {value:'heat',name:'Heat'}
      ]);
      ctrlColor(g3, 'particles.solidColor', 'Solid color');
      ctrlSelect(g3, 'particles.palette', 'Palette', [
        {value:'plasma',name:'Plasma'},
        {value:'cool',name:'Cool'},
        {value:'fire',name:'Fire'},
        {value:'aurora',name:'Aurora'}
      ]);
      ctrlRange(g3, 'particles.velocityColorScale', 'Velocity color scale', 40, 1200, 10, v=>v.toFixed(0));
      ctrlSelect(g3,'particles.blend','Blend mode',[
        {value:'source-over',name:'Normal'},
        {value:'lighter',name:'Additive'},
        {value:'screen',name:'Screen'},
        {value:'multiply',name:'Multiply'}
      ]);
      ctrlRange(g3,'particles.opacity','Particle opacity',0.1,1.0,0.05,v=>v.toFixed(2));

      contentEl.append(g1,g2,g3);
    }
    if(id==='physics'){
      const g = group('Forces');
      ctrlRange(g,'physics.gravity','Gravity',0,1200,10,v=>v.toFixed(0));
      ctrlRange(g,'physics.tiltSensitivity','Tilt sensitivity',0,3,0.05,v=>v.toFixed(2));
      ctrlRange(g,'physics.airDrag','Air drag',0,1.2,0.01,v=>v.toFixed(2));
      ctrlNumber(g,'physics.windX','Wind X',1);
      ctrlNumber(g,'physics.windY','Wind Y',1);

      const g2 = group('Boundaries & Materials');
      const bSel = ctrlSelect(g2,'physics.boundaries','Boundaries',[
        {value:'screen-bounce',name:'Screen: Bounce'},
        {value:'screen-wrap',name:'Screen: Wrap'},
        {value:'none',name:'None'},
        {value:'container-circle',name:'Container: Circle'},
        {value:'container-square',name:'Container: Square'}
      ], ()=>{ rebuildParticles(false); showTab('physics'); });
      ctrlRange(g2,'physics.restitution','Bounciness',0,1,0.01,v=>v.toFixed(2));
      ctrlRange(g2,'physics.wallFriction','Wall friction',0,0.5,0.01,v=>v.toFixed(2));
      ctrlRange(g2,'physics.particleFriction','Particle fric.',0,0.5,0.01,v=>v.toFixed(2));

      const mode = mapBoundaries(Settings.physics.boundaries);
      if(mode==='container-circle' || mode==='container-square'){
        const gc = group('Container Settings');
        ctrlRange(gc,'physics.container.cx','Center X (norm)',0,1,0.01,v=>v.toFixed(2));
        ctrlRange(gc,'physics.container.cy','Center Y (norm)',0,1,0.01,v=>v.toFixed(2));
        if(mode==='container-circle'){
          ctrlRange(gc,'physics.container.radiusN','Radius (norm)',0.05,0.8,0.005,v=>v.toFixed(3));
        }else{
          ctrlRange(gc,'physics.container.sizeN','Half-size (norm)',0.05,0.8,0.005,v=>v.toFixed(3));
        }
        contentEl.append(gc);
      }

      contentEl.append(g,g2);
    }
    if(id==='forces'){
      const mode = Settings.forces.turbulenceMode;

      const g = group('Turbulence');
      ctrlSelect(g,'forces.turbulenceMode','Mode',[
        {value:'none',name:'None'},
        {value:'flow',name:'Flow'},
        {value:'curl',name:'Curl'},
        {value:'vortex',name:'Vortex (single)'},
        {value:'wind',name:'Wind (gusty)'},
        {value:'jets',name:'Jets (banded)'},
        {value:'swirlgrid',name:'Swirl Grid'},
        {value:'wells',name:'Wells (multi-attractor)'}
      ], ()=>showTab('forces'));
      ctrlRange(g,'forces.amplitude','Amplitude',0,1600,10,v=>v.toFixed(0));
      ctrlRange(g,'forces.scale','Scale',0.0005,0.02,0.0005,v=>v.toFixed(4));
      ctrlRange(g,'forces.timeScale','Time scale',0,2,0.01,v=>v.toFixed(2));
      contentEl.append(g);

      if(mode==='curl'){
        const g2 = group('Curl options');
        ctrlRange(g2,'forces.curlStrength','Curl strength',0,3,0.05,v=>v.toFixed(2));
        contentEl.append(g2);
      }
      if(mode==='vortex'){
        const g3 = group('Vortex options');
        ctrlRange(g3,'forces.vortexX','Center X (norm)',0,1,0.01,v=>v.toFixed(2));
        ctrlRange(g3,'forces.vortexY','Center Y (norm)',0,1,0.01,v=>v.toFixed(2));
        ctrlRange(g3,'forces.vortexStrength','Strength',0,2000,10,v=>v.toFixed(0));
        ctrlRange(g3,'forces.vortexFalloff','Falloff',0,3,0.05,v=>v.toFixed(2));
        ctrlCheck(g3,'forces.vortexCW','Clockwise');
        contentEl.append(g3);
      }
      if(mode==='wind'){
        const g4 = group('Wind options');
        ctrlRange(g4,'forces.windVar','Variability',0,200,1,v=>v.toFixed(0));
        ctrlRange(g4,'forces.windGust','Gust',0,400,1,v=>v.toFixed(0));
        contentEl.append(g4);
      }
      if(mode==='jets'){
        const g5 = group('Jets options');
        ctrlRange(g5,'forces.jetsAngle','Angle (deg)',0,360,1,v=>v.toFixed(0));
        ctrlRange(g5,'forces.jetsSpacing','Band spacing (px)',30,400,1,v=>v.toFixed(0));
        contentEl.append(g5);
      }
      if(mode==='swirlgrid'){
        const g6 = group('Swirl Grid options');
        ctrlRange(g6,'forces.swirlSpacing','Cell spacing (px)',40,400,1,v=>v.toFixed(0));
        ctrlRange(g6,'forces.swirlFalloff','Falloff',0,3,0.05,v=>v.toFixed(2));
        ctrlCheck(g6,'forces.swirlAlt','Alternate CW/CCW');
        contentEl.append(g6);
      }
      if(mode==='wells'){
        const g7 = group('Wells options');
        ctrlRange(g7,'forces.wellsCount','Count',1,8,1,v=>v.toFixed(0));
        ctrlRange(g7,'forces.wellsStrength','Strength',0,2000,10,v=>v.toFixed(0));
        ctrlRange(g7,'forces.wellsFalloff','Falloff',0.2,3,0.05,v=>v.toFixed(2));
        ctrlRange(g7,'forces.wellsSpin','Spin',0,2,0.01,v=>v.toFixed(2));
        ctrlCheck(g7,'forces.wellsMove','Move');
        ctrlCheck(g7,'forces.wellsRepel','Repel (instead of attract)');
        contentEl.append(g7);
      }
    }
    if(id==='collisions'){
      const g = group('Collisions');
      ctrlSelect(g,'collisions.mode','Mode',[
        {value:'elastic',name:'Elastic'},
        {value:'soft',name:'Soft'},
        {value:'inelastic',name:'Inelastic'},
        {value:'none',name:'None'}
      ]);
      ctrlCheck(g,'collisions.enable','Enable collisions');
      ctrlRange(g,'collisions.softness','Softness',0,1,0.01,v=>v.toFixed(2));
      ctrlRange(g,'collisions.inelasticity','Inelasticity',0,1,0.01,v=>v.toFixed(2));
      ctrlCheck(g,'collisions.adapt','Adaptive disable at low FPS');
      contentEl.append(g);
    }
    if(id==='visuals'){
      const g = group('Rendering');
      ctrlColor(g,'visuals.background','Background', (v)=>{ document.body.style.background = v; });
      ctrlRange(g,'visuals.trail','Trail persistence',0,0.9,0.01,v=>v.toFixed(2));
      ctrlCheck(g,'visuals.showContainer','Show container outline');
      ctrlCheck(g,'visuals.showHUD','Show HUD', v=>{ document.getElementById('hud').style.display = v?'block':'none'; });
      ctrlCheck(g,'visuals.wireframe','Wireframe');
      contentEl.append(g);
    }
    if(id==='interact'){
      const g = group('Pointer');
      ctrlCheck(g,'pointer.enabled','Pointer enabled');
      ctrlSelect(g,'pointer.tool','Tool',[
        {value:'none',name:'None'},
        {value:'attract',name:'Attract'},
        {value:'repel',name:'Repel'},
        {value:'push',name:'Push (drag)'},
        {value:'spin',name:'Spin'}
      ]);
      ctrlRange(g,'pointer.strength','Tool strength',0,3000,10,v=>v.toFixed(0));
      ctrlRange(g,'pointer.radius','Tool radius',20,400,1,v=>v.toFixed(0));
      const g2 = group('Gravity Control');
      ctrlCheck(g2,'controls.mouseSetsGravity','Mouse sets gravity', v=>updateHUD());
      const hint = document.createElement('div'); hint.className='smallnote'; hint.textContent = 'Click anywhere to tilt toward that point (sticky).';
      g2.appendChild(hint);
      contentEl.append(g,g2);
    }
    if(id==='performance'){
      const g = group('Performance');
      ctrlRange(g,'performance.simSpeed','Simulation speed',0.1,2,0.01,v=>v.toFixed(2));
      ctrlRange(g,'performance.substeps','Substeps',1,9,1,v=>v.toFixed(0), v=>{ substeps = Math.round(v); });
      ctrlCheck(g,'performance.adaptive','Adaptive mode');
      ctrlRange(g,'performance.lowFpsThreshold','Low FPS threshold',20,58,1,v=>v.toFixed(0));
      ctrlRange(g,'performance.collisionCap','Neighbor cap',4,48,1,v=>v.toFixed(0));
      const note = document.createElement('div'); note.className='smallnote';
      note.textContent = 'Tip: For 5kâ€“8k particles, set collisions to Soft or None. Adaptive mode reduces cost if FPS drops.';
      g.appendChild(note);
      contentEl.append(g);
    }
    if(id==='about'){
      const g = group('About this playground');
      const div = document.createElement('div');
      div.innerHTML = `
        <div class="rowline" style="line-height:1.55">
          Container boundaries (circle/square), new turbulence modes (Jets, Swirl Grid, Wells), and a Uniform Size option have been added.
          <ul>
            <li>Mobile: Tap <b>Enable Tilt</b>, then roll your phone to move marbles.</li>
            <li>Desktop: Click anywhere to set the "downhill" direction.</li>
            <li>Keyboard: Space = pause, C = controls, G = toggle mouse-gravity, R = reset.</li>
          </ul>
        </div>
      `;
      g.appendChild(div);
      contentEl.append(g);
    }
  }

  // Randomize button
  randomizeBtn.addEventListener('click', ()=>{
    Settings.particles.count = Math.round(rand(300, 2800));
    Settings.particles.uniformSize = Math.random()<0.35;
    if(Settings.particles.uniformSize){
      Settings.particles.radiusMax = rand(1.5,6);
      Settings.particles.radiusMin = Settings.particles.radiusMax;
    }else{
      Settings.particles.radiusMin = rand(1,4);
      Settings.particles.radiusMax = Settings.particles.radiusMin + rand(1,4);
    }
    Settings.particles.shape = ['circle','square','triangle'][randInt(0,2)];
    Settings.particles.colorMode = ['solid','velocity','heat'][randInt(0,2)];
    Settings.particles.palette = ['plasma','cool','fire','aurora'][randInt(0,3)];
    Settings.particles.blend = ['source-over','lighter','screen','multiply'][randInt(0,3)];
    Settings.physics.gravity = rand(0,800);
    Settings.physics.airDrag = rand(0.01,0.4);
    Settings.physics.restitution = rand(0.1,0.9);
    Settings.collisions.mode = ['elastic','soft','inelastic','none'][randInt(0,3)];
    Settings.forces.turbulenceMode = ['none','flow','curl','vortex','wind','jets','swirlgrid','wells'][randInt(0,7)];
    Settings.forces.amplitude = rand(0,800);
    Settings.forces.scale = rand(0.001,0.008);
    Settings.forces.timeScale = rand(0,1.2);
    Settings.physics.boundaries = ['screen-bounce','screen-wrap','none','container-circle','container-square'][randInt(0,4)];
    rebuildParticles(false);
    makeTabs(); // refresh UI
  });

  // Presets menu
  presetMenuBtn.addEventListener('click', ()=>{
    const names = Object.keys(PRESETS);
    const choice = prompt('Load preset: ' + names.join(', '), 'Marbles');
    if(!choice) return;
    const presetFn = PRESETS[choice.trim()];
    if(presetFn){
      const p = presetFn();
      Object.keys(p).forEach(section=>{
        Object.assign(Settings[section], p[section]);
      });
      if(Settings.particles.uniformSize){ Settings.particles.radiusMin = Settings.particles.radiusMax; }
      rebuildParticles(false);
      makeTabs();
    }else{
      alert('Preset not found.');
    }
  });

  makeTabs();
  document.body.style.background = Settings.visuals.background;
  rebuildParticles(false);

  // HUD update
  function updateHUD(){
    hud.pcount.textContent = particles.length;
    hud.collMode.textContent = Settings.collisions.mode;
    hud.turbMode.textContent = Settings.forces.turbulenceMode;
    hud.tiltState.textContent = tiltEnabled? 'on':'off';
    hud.mouseG.textContent = Settings.controls.mouseSetsGravity? 'on':'off';
  }
  updateHUD();

  if(haveDeviceOrientation){
    setTimeout(()=>{ tiltPrompt.hidden = false; }, 600);
  }

  // Spatial hash
  function buildGrid(){
    grid.clear();
    const cell = gridCell;
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      const cx = (p.x/cell)|0, cy=(p.y/cell)|0;
      const key = (cx<<16) ^ cy;
      let list = grid.get(key);
      if(!list){ list = []; grid.set(key,list); }
      list.push(i);
    }
  }
  function neighbors(i){
    const res = [];
    const cell = gridCell;
    const p = particles[i];
    const cx = (p.x/cell)|0, cy=(p.y/cell)|0;
    for(let ox=-1; ox<=1; ox++){
      for(let oy=-1; oy<=1; oy++){
        const key = ((cx+ox)<<16) ^ (cy+oy);
        const list = grid.get(key);
        if(list) for(let j of list){ if(j!==i) res.push(j); }
      }
    }
    return res;
  }

  function applyOpacityToColor(col, alpha){
    if(col.startsWith('#')){
      const r = parseInt(col.slice(1,3),16);
      const g = parseInt(col.slice(3,5),16);
      const b = parseInt(col.slice(5,7),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    if(col.startsWith('rgb')){
      return col.replace('rgb','rgba').replace(')',`,`+alpha+`)`);
    }
    return col;
  }

  function drawParticle(p){
    const opacity = Settings.particles.opacity;
    const cm = Settings.particles.colorMode;
    if(cm==='solid'){
      ctx.fillStyle = applyOpacityToColor(Settings.particles.solidColor, opacity);
    }else if(cm==='velocity'){
      const spd = Math.hypot(p.vx,p.vy);
      const t = clamp(spd / Settings.particles.velocityColorScale, 0,1);
      ctx.fillStyle = applyOpacityToColor(paletteColor(t, Settings.particles.palette), opacity);
    }else if(cm==='heat'){
      const t = clamp(p.heat,0,1);
      ctx.fillStyle = applyOpacityToColor(paletteColor(t, 'fire'), opacity);
    }
    const r = p.r;
    if(Settings.particles.shape==='circle'){
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, TAU);
      ctx.fill();
    }else if(Settings.particles.shape==='square'){
      ctx.fillRect(p.x-r, p.y-r, r*2, r*2);
    }else{
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - r);
      ctx.lineTo(p.x + r, p.y + r);
      ctx.lineTo(p.x - r, p.y + r);
      ctx.closePath();
      ctx.fill();
    }
    if(Settings.visuals.wireframe){
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.stroke();
    }
  }

  function mapBoundaries(v){
    if(v==='bounce') return 'screen-bounce';
    if(v==='wrap') return 'screen-wrap';
    return v;
  }

  // Wells positions
  function computeWellsPositions(t){
    const rng = LCG(Settings.forces.wellsSeed);
    const BW = canvas.width/DPR, BH = canvas.height/DPR;
    const n = clamp(Math.round(Settings.forces.wellsCount),1,8);
    const res = [];
    for(let i=0;i<n;i++){
      const bx = 0.15 + 0.7 * rng();
      const by = 0.15 + 0.7 * rng();
      let x = bx*BW, y = by*BH;
      if(Settings.forces.wellsMove){
        const phase = i*1.7;
        x += Math.sin(t*0.6 + phase) * 0.12 * Math.min(BW,BH);
        y += Math.cos(t*0.5 + phase*1.3) * 0.10 * Math.min(BW,BH);
      }
      res.push({x,y, sign: (i%2===0?1:-1)});
    }
    return res;
  }

  // Main loop
  function frame(t){
    const dtRaw = Math.min(1/20, (t-lastT)/1000) * Settings.performance.simSpeed;
    lastT = t;
    const fps = 1/Math.max(1e-6, dtRaw);
    fpsSmooth = fpsSmooth*0.9 + fps*0.1;
    hud.fps.textContent = fpsSmooth.toFixed(0);
    recentFps.push(fps); if(recentFps.length>30) recentFps.shift();

    if(Settings.performance.adaptive && frameCount%30===0){
      const avgFps = recentFps.reduce((a,b)=>a+b,0)/Math.max(1,recentFps.length);
      Settings.collisions.enable = avgFps >= Settings.performance.lowFpsThreshold;
      updateHUD();
    }

    if(running || stepOnce){
      const dt = dtRaw;
      let sub = substeps|0; if(sub<1) sub=1;
      const h = dt/sub;

      const gmag = Settings.physics.gravity;
      const sourceG = Settings.controls.mouseSetsGravity ? mouseGravity : gDir;
      const gxBase = sourceG.x * gmag * Settings.physics.tiltSensitivity;
      const gyBase = sourceG.y * gmag * Settings.physics.tiltSensitivity;

      // Clear / trails
      if(Settings.visuals.trail<=0.001){
        ctx.fillStyle = Settings.visuals.background;
        ctx.fillRect(0,0,canvas.width/DPR, canvas.height/DPR);
      }else{
        ctx.fillStyle = hexWithAlpha(Settings.visuals.background, 1-Settings.visuals.trail);
        ctx.fillRect(0,0,canvas.width/DPR, canvas.height/DPR);
      }

      if(Settings.collisions.enable && Settings.collisions.mode!=='none'){
        buildGrid();
      }

      for(let s=0; s<sub; s++){
        const time = (t/1000);
        const BW = canvas.width/DPR, BH = canvas.height/DPR;
        const bMode = mapBoundaries(Settings.physics.boundaries);

        // Precompute turbulence field settings
        const tm = Settings.forces.turbulenceMode;
        const amp = Settings.forces.amplitude;
        const sca = Settings.forces.scale;
        const tscale = Settings.forces.timeScale;
        const tt = time * tscale;

        // Pointer influence
        const ptrActive = Settings.pointer.enabled && pointer.active;

        // Wells precompute
        let wells = null;
        if(tm==='wells') wells = computeWellsPositions(time);

        for(let i=0;i<particles.length;i++){
          const p = particles[i];

          // Base forces
          let ax = gxBase/p.m + Settings.physics.windX/p.m;
          let ay = gyBase/p.m + Settings.physics.windY/p.m;

          // Turbulence modes
          if(tm==='flow'){
            const v = flowNoiseVec(p.x, p.y, tt, sca, amp/p.m);
            ax += v.x; ay += v.y;
          }else if(tm==='curl'){
            const v = curlNoise(p.x, p.y, tt, sca, amp*Settings.forces.curlStrength/p.m);
            ax += v.x; ay += v.y;
          }else if(tm==='vortex'){
            const cx = Settings.forces.vortexX * BW;
            const cy = Settings.forces.vortexY * BH;
            let dx = p.x - cx, dy = p.y - cy;
            let r2 = dx*dx + dy*dy;
            let r = Math.sqrt(r2) + 1e-4;
            let strength = Settings.forces.vortexStrength / Math.pow(r, Settings.forces.vortexFalloff);
            let tx = -dy/r, ty = dx/r;
            if(!Settings.forces.vortexCW){ tx = -tx; ty = -ty; }
            ax += tx * strength / p.m;
            ay += ty * strength / p.m;
            const cent = amp*0.1 / p.m;
            ax += -dx/r * cent; ay += -dy/r * cent;
          }else if(tm==='wind'){
            const v = flowNoiseVec(p.x*0.7, p.y*0.7, tt, sca*0.6, (Settings.forces.windVar||0));
            const gust = flowNoiseVec(p.x*0.3, p.y*0.3, tt*1.7, sca*0.4, (Settings.forces.windGust||0));
            ax += (v.x + gust.x)/p.m;
            ay += (v.y + gust.y)/p.m;
          }else if(tm==='jets'){
            const ang = Settings.forces.jetsAngle*DEG;
            const ux = Math.cos(ang), uy = Math.sin(ang);
            const phi = ((p.x*ux + p.y*uy) / Math.max(10,Settings.forces.jetsSpacing)) * TAU + tt*2.0;
            const band = Math.sin(phi);
            const F = amp * band / p.m;
            ax += ux * F; ay += uy * F;
          }else if(tm==='swirlgrid'){
            const spacing = Math.max(20, Settings.forces.swirlSpacing);
            const cxg = Math.floor(p.x/spacing)*spacing + spacing*0.5;
            const cyg = Math.floor(p.y/spacing)*spacing + spacing*0.5;
            const dx = p.x - cxg, dy = p.y - cyg;
            const r = Math.hypot(dx,dy) + 1e-3;
            let cw = Settings.forces.vortexCW ? 1 : -1;
            if(Settings.forces.swirlAlt){
              const px = Math.floor(p.x/spacing), py = Math.floor(p.y/spacing);
              if(((px+py)&1)===1) cw = -cw;
            }
            const tx = (-dy/r)*cw, ty = (dx/r)*cw;
            const fall = 1/Math.pow(1 + (r/spacing), Settings.forces.swirlFalloff);
            const F = amp * fall / p.m;
            ax += tx * F; ay += ty * F;
          }else if(tm==='wells' && wells){
            const falloff = Settings.forces.wellsFalloff;
            const k = Settings.forces.wellsStrength;
            for(let w=0; w<wells.length; w++){
              const wx = wells[w].x, wy = wells[w].y;
              const dx = wx - p.x, dy = wy - p.y;
              const r = Math.hypot(dx,dy) + 1e-3;
              const nx = dx/r, ny = dy/r;
              const sgn = Settings.forces.wellsRepel ? -1 : 1;
              const base = k / Math.pow(r, falloff);
              // radial attract/repel
              ax += nx * base * sgn / p.m;
              ay += ny * base * sgn / p.m;
              // tangential swirl
              const cw = (w%2===0?1:-1);
              const tx = -ny*cw, ty = nx*cw;
              const spin = Settings.forces.wellsSpin * base / p.m;
              ax += tx * spin; ay += ty * spin;
            }
          }

          // Pointer tool
          if(ptrActive && Settings.pointer.tool!=='none'){
            const dx = p.x - pointer.x;
            const dy = p.y - pointer.y;
            const d2 = dx*dx + dy*dy;
            const rr = Settings.pointer.radius;
            if(d2 < rr*rr){
              const d = Math.sqrt(d2) + 1e-4;
              const nx = dx/d, ny = dy/d;
              const fall = 1 - d/rr;
              const F = Settings.pointer.strength * fall * fall / p.m;
              if(Settings.pointer.tool==='attract'){
                ax += -nx * F; ay += -ny * F;
              }else if(Settings.pointer.tool==='repel'){
                ax += nx * F; ay += ny * F;
              }else if(Settings.pointer.tool==='push'){
                ax += (pointer.dx*60) * fall / p.m;
                ay += (pointer.dy*60) * fall / p.m;
              }else if(Settings.pointer.tool==='spin'){
                ax += (-ny) * F * 0.8;
                ay += ( nx) * F * 0.8;
              }
            }
          }

          // Air drag
          const drag = Settings.physics.airDrag;
          p.vx += (ax - p.vx*drag)*h;
          p.vy += (ay - p.vy*drag)*h;

          // Integrate
          p.x += p.vx * h;
          p.y += p.vy * h;

          // Heat from drag
          if(Settings.particles.colorMode==='heat'){
            const speed2 = p.vx*p.vx + p.vy*p.vy;
            p.heat = p.heat*heatDecay + clamp(speed2*0.000001, 0, 0.05);
          }

          // Boundaries
          const e = Settings.physics.restitution;
          const wf = Settings.physics.wallFriction;
          if(bMode==='screen-bounce'){
            if(p.x < p.r){ p.x = p.r; if(p.vx<0){ const vt = p.vy; p.vx = -p.vx*e; p.vy = vt*(1-wf); } }
            else if(p.x > BW - p.r){ p.x=BW-p.r; if(p.vx>0){ const vt = p.vy; p.vx = -p.vx*e; p.vy = vt*(1-wf);} }
            if(p.y < p.r){ p.y = p.r; if(p.vy<0){ const vt = p.vx; p.vy = -p.vy*e; p.vx = vt*(1-wf);} }
            else if(p.y > BH - p.r){ p.y=BH-p.r; if(p.vy>0){ const vt = p.vx; p.vy = -p.vy*e; p.vx = vt*(1-wf);} }
          }else if(bMode==='screen-wrap'){
            if(p.x < -p.r) p.x = BW + p.r;
            if(p.x > BW + p.r) p.x = -p.r;
            if(p.y < -p.r) p.y = BH + p.r;
            if(p.y > BH + p.r) p.y = -p.r;
          }else if(bMode==='container-circle'){
            const cx = Settings.physics.container.cx * BW;
            const cy = Settings.physics.container.cy * BH;
            const R = Settings.physics.container.radiusN * (Math.min(BW,BH)/2);
            const dx = p.x - cx, dy = p.y - cy;
            const dist = Math.hypot(dx,dy) || 1e-6;
            const allow = Math.max(2, R - p.r);
            if(dist > allow){
              const nx = dx/dist, ny = dy/dist;
              p.x = cx + nx*allow;
              p.y = cy + ny*allow;
              const vn = p.vx*nx + p.vy*ny;
              // reflect normal
              p.vx = p.vx - (1+e)*vn*nx;
              p.vy = p.vy - (1+e)*vn*ny;
              // tangential friction
              const tnx = -ny, tny = nx;
              const vt = p.vx*tnx + p.vy*tny;
              p.vx -= tnx * vt * wf;
              p.vy -= tny * vt * wf;
            }
          }else if(bMode==='container-square'){
            const cx = Settings.physics.container.cx * BW;
            const cy = Settings.physics.container.cy * BH;
            const half = Settings.physics.container.sizeN * (Math.min(BW,BH)/2);
            const minX = cx - half + p.r, maxX = cx + half - p.r;
            const minY = cy - half + p.r, maxY = cy + half - p.r;
            if(p.x < minX){ p.x = minX; if(p.vx<0){ const vt = p.vy; p.vx = -p.vx*e; p.vy = vt*(1-wf); } }
            else if(p.x > maxX){ p.x = maxX; if(p.vx>0){ const vt = p.vy; p.vx = -p.vx*e; p.vy = vt*(1-wf);} }
            if(p.y < minY){ p.y = minY; if(p.vy<0){ const vt = p.vx; p.vy = -p.vy*e; p.vx = vt*(1-wf);} }
            else if(p.y > maxY){ p.y = maxY; if(p.vy>0){ const vt = p.vx; p.vy = -p.vy*e; p.vx = vt*(1-wf);} }
          }else{
            // none: let them float far and wrap softly to keep camera area populated
            if(p.x < -BW) p.x = BW*2;
            if(p.x > BW*2) p.x = -BW;
            if(p.y < -BH) p.y = BH*2;
            if(p.y > BH*2) p.y = -BH;
          }
        }

        // Collisions
        if(Settings.collisions.enable && Settings.collisions.mode!=='none'){
          const mode = Settings.collisions.mode;
          const cap = Settings.performance.collisionCap|0;
          const rest = Settings.physics.restitution * (mode==='inelastic' ? (1-Settings.collisions.inelasticity) : 1);
          for(let i=0;i<particles.length;i++){
            const p = particles[i];
            const neigh = neighbors(i);
            let handled = 0;
            for(let idx=0; idx<neigh.length; idx++){
              const j = neigh[idx];
              if(j<=i) continue;
              const q = particles[j];
              const dx = q.x - p.x, dy = q.y - p.y;
              const sr = p.r + q.r;
              if(dx*dx + dy*dy <= sr*sr){
                const d = Math.sqrt(dx*dx + dy*dy) || 1e-4;
                const nx = dx/d, ny = dy/d;
                const overlap = sr - d;

                if(mode==='soft'){
                  const k = Settings.collisions.softness;
                  const push = overlap*0.5*k;
                  p.x -= nx*push; p.y -= ny*push;
                  q.x += nx*push; q.y += ny*push;
                  const rvx = q.vx - p.vx, rvy = q.vy - p.vy;
                  const vn = rvx*nx + rvy*ny;
                  const damp = (1 + rest)*0.5 * vn;
                  p.vx += nx * damp * (1/(p.m+q.m)) * q.m;
                  p.vy += ny * damp * (1/(p.m+q.m)) * q.m;
                  q.vx -= nx * damp * (1/(p.m+q.m)) * p.m;
                  q.vy -= ny * damp * (1/(p.m+q.m)) * p.m;
                }else{
                  const correction = overlap*0.5;
                  p.x -= nx*correction; p.y -= ny*correction;
                  q.x += nx*correction; q.y += ny*correction;

                  const rvx = q.vx - p.vx, rvy = q.vy - p.vy;
                  const vn = rvx*nx + rvy*ny;
                  if(vn < 0){
                    const e = rest;
                    const invMassSum = 1/p.m + 1/q.m;
                    const jimp = -(1+e)*vn / invMassSum;
                    const ix = nx*jimp, iy = ny*jimp;
                    p.vx -= ix/p.m; p.vy -= iy/p.m;
                    q.vx += ix/q.m; q.vy += iy/q.m;

                    const fr = Settings.physics.particleFriction;
                    const tvx = rvx - vn*nx, tvy = rvy - vn*ny;
                    const tlen = Math.hypot(tvx,tvy)||1e-6;
                    const tx = tvx/tlen, ty = tvy/tlen;
                    const jt = -fr * jimp;
                    p.vx -= tx*jt/p.m; p.vy -= ty*jt/p.m;
                    q.vx += tx*jt/q.m; q.vy += ty*jt/q.m;

                    if(Settings.particles.colorMode==='heat'){
                      const loss = (1-rest)*Math.abs(vn)*0.02;
                      p.heat = clamp(p.heat + loss, 0, 1.2);
                      q.heat = clamp(q.heat + loss, 0, 1.2);
                    }
                  }
                }

                handled++; if(handled>cap) break;
              }
            }
          }
        }
      }

      // Draw particles
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalCompositeOperation = Settings.particles.blend;
      for(let i=0;i<particles.length;i++){
        drawParticle(particles[i]);
      }

      // Draw container outline (if any)
      const bMode = mapBoundaries(Settings.physics.boundaries);
      if(Settings.visuals.showContainer && (bMode==='container-circle' || bMode==='container-square')){
        const BW = canvas.width/DPR, BH = canvas.height/DPR;
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 2;
        const cx = Settings.physics.container.cx * BW;
        const cy = Settings.physics.container.cy * BH;
        const minDim = Math.min(BW,BH);
        if(bMode==='container-circle'){
          const R = Settings.physics.container.radiusN * (minDim/2);
          ctx.beginPath(); ctx.arc(cx,cy,R,0,TAU); ctx.stroke();
        }else{
          const half = Settings.physics.container.sizeN * (minDim/2);
          ctx.strokeRect(cx-half, cy-half, half*2, half*2);
        }
      }

      // Visualize gravity direction
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = 'rgba(106,227,255,0.6)';
      ctx.lineWidth = 2;
      const cxv = canvas.width/DPR/2, cyv = canvas.height/DPR/2;
      const gv = Settings.controls.mouseSetsGravity ? mouseGravity : gDir;
      ctx.beginPath();
      ctx.moveTo(cxv,cyv);
      ctx.lineTo(cxv + gv.x*0, cyv + gv.y*0); //set zeros back to 40 for gravity on screen indicator to appear
      ctx.stroke();

      stepOnce=false;
    }

    frameCount++;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function hexWithAlpha(hex, a){
    if(!hex || hex[0]!=='#') return hex;
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // Initial mouse gravity center
  setMouseGravityFromPoint(canvas.clientWidth/2, canvas.clientHeight/2);

  // Sticky mouse gravity
  canvas.addEventListener('click', (e)=>{
    if(Settings.controls.mouseSetsGravity){
      setMouseGravityFromPoint(e.clientX, e.clientY);
    }
  });

  // Keep labels updated periodically
  setInterval(updateHUD, 400);

})();
</script>
</body>

</html>
